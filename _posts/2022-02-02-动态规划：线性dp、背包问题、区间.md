---
layout: post
title: 线性dp、背包问题、区间dp
subheading: 动态规划1
author: te4p0t
categories: coding
tags: Coding

---



# 动态规划：线性dp、背包问题、区间dp

### bitset使用

bitset常用构造函数有四种，如下

```cpp
    bitset<4> bitset1;　　//无参构造，长度为４，默认每一位为０

    bitset<8> bitset2(12);　　//长度为８，二进制保存，前面用０补充

    string s = "100101";
    bitset<10> bitset3(s);　　//长度为10，前面用０补充

    char s2[] = "10101";
    bitset<13> bitset4(s2);　　//长度为13，前面用０补充

    cout << bitset1 << endl;　　//0000
    cout << bitset2 << endl;　　//00001100
    cout << bitset3 << endl;　　//0000100101
    cout << bitset4 << endl;　　//0000000010101
```

注意：

用字符串构造时，字符串只能包含 '0' 或 '1' ，否则会抛出异常。

构造时，需在<>中表明bitset 的大小(即size)。

在进行有参构造时，若参数的二进制表示比bitset的size小，则在前面用０补充(如上面的栗子)；若比bitsize大，参数为整数时取后面部分，参数为字符串时取前面部分

bitset支持位操作符运算和数组下标访问，底层使用int实现。

```cpp
    bitset<8> foo ("10011011");

    cout << foo.count() << endl;　　//5　　（count函数用来求bitset中1的位数，foo***有５个１
    cout << foo.size() << endl;　　 //8　　（size函数用来求bitset的大小，一共有８位

    cout << foo.test(0) << endl;　　//true　　（test函数用来查下标处的元素是０还是１，并返回false或true，此处foo[0]为１，返回true
    cout << foo.test(2) << endl;　　//false　　（同理，foo[2]为０，返回false

    cout << foo.any() << endl;　　//true　　（any函数检查bitset中是否有１
    cout << foo.none() << endl;　　//false　　（none函数检查bitset中是否没有１
    cout << foo.all() << endl;　　//false　　（all函数检查bitset中是全部为１

    cout << foo.flip(2) << endl;　　//10011111　　（flip函数传参数时，用于将参数位取反，本行代码将foo下标２处"反转"，即０变１，１变０
    cout << foo.flip() << endl;　　 //01100000　　（flip函数不指定参数时，将bitset每一位全部取反

    cout << foo.set() << endl;　　　　//11111111　　（set函数不指定参数时，将bitset的每一位全部置为１
    cout << foo.set(3,0) << endl;　　//11110111　　（set函数指定两位参数时，将第一参数位的元素置为第二参数的值，本行对foo的操作相当于foo[3]=0
    cout << foo.set(3) << endl;　　  //11111111　　（set函数只有一个参数时，将参数下标处置为１

    cout << foo.reset(4) << endl;　　//11101111　　（reset函数传一个参数时将参数下标处置为０
    cout << foo.reset() << endl;　　 //00000000　　（reset函数不传参数时将bitset的每一位全部置为０



    string s = foo.to_string();　　//将bitset转换成string类型
    unsigned long a = foo.to_ulong();　　//将bitset转换成unsigned long类型
    unsigned long long b = foo.to_ullong();　　//将bitset转换成unsigned long long类型

    cout << s << endl;　　//10011011
    cout << a << endl;　　//155
    cout << b << endl;　　//155
```

## 记忆化搜索

顾名思义，就是带有记忆的搜索

也就是说，用数组将已经计算过的东西记录下来在下一次要使用的时候直接用已经算出的值，避免重复计算，去掉重复的搜索树。

#### 待完成

poj数字三角形

## 动态规划原理

**分类加法原理**

- 做一件事，完成它可以有n类方法，在第一类办法中有$m_1$种不同的方法，在第二类办法中有$m_2$种不同的方法,...，在第n类办法中有$m_n$种不同的方法，那么完成这件事共有$N=m_1+m_2+...+m_n$种不同的方法。

**分步乘法原理**

- 做一件事，完成它需要分成n个步骤，做第一步有$m_1$种不同的方法，做第二步有$m_2$种不同的方法,...，做第n步有$m_n$种不同的方法，那么完成它这件事共有$N=m_1 \times m_2 \times ... \times m_n $种不同的方法。

**下面给出若干概念**

**动规**：动态规划是解决**多阶段决策过程最优化**问题的一种方法

**阶段**：把问题分成几个相互联系的有顺序的几个环节，这些环节即称为阶段。

**状态**：某一阶段的**出发位置**称为状态。通常一个阶段包含若干状态。

**决策**：从某阶段的一个状态演变到下一个阶段某状态的选择。

**策略**：由开始到终点的全过程中，由每段决策组成的决策序列称为全过程决策，简称决策。

**状态转移方程**：前一阶段的终点就是后一阶段的起点，前一阶段的决策选择导出了后一阶段的状态，这种关系描述了由i阶段到i+1阶段的演变规律，称为状态转移方程。

## 动态规划适用的基本条件

**具有相同子问题**

- 首先，我们必须要保证这个问题能够分解出几个子问题，并且能够通过这些子问题来解决这个问题。
- 其次，将这些子问题做为一个新的问题，它也能分解为相同的子问题进行求解。
- 也就是说，假设我们一个问题被分解为了A、B、C三个部分，那么这A、B、C分别也能被分解为A' B' C'三个部分，而不能是D、E、F三个部分。

**满足最优子结构**

- 问题的最优解包含着它的子问题的最优解。即不管前面的策略如何，此后的决策必须是基于当前状态（由上一次决策产生）的最优决策。

**满足无后效性**

- “过去的步骤只能通过当前状态影响未来的发展，当前的状态是**历史的总结**”。这条特征说明**动态规划只适用于解决当前决策与过去状态无关的问题**。状态，出现在策略任何一个位置，它的地位相同，都可实施同样策略，这就是无后效性的内涵。
- 这是动态规划中极为重要的一点，如果当前问题的具体决策，会对解决它未来的问题产生影响，如果产生影响，就无法保证决策的最优性。

## 做动态规划的一般步骤

1. 结合原问题和子问题确定状态（我是谁？我在哪？）
   - 题目在求什么？要求这个值我们需要知道什么？什么是影响答案的因素？
   - （一维状态描述不完就二维，二维不行就三维四维）
   - 状态的参数一般有：
   - 描述位置的：前（后）i单位，第i到第j单位，坐标为（i, j），第i个之前（后）且必须取第i个等。
   - 描述数量的：取i个，不超过i个，至少i个等
   - 描述对后有影响的：状态压缩的，一些特殊的性质

2. 确定转移方程（我从哪里来？我到哪里去？）
   - 检查参数是否足够
   - 分情况：最后一次操作的方式，取不取，怎么样取——前一项是什么
   - 初始边界是什么
   - 注意无后效性。比如说，求A要求B，求B就要求C，而求C就要求A，这就不符合无后效性了。

根据状态**枚举最后一次决策**（即当前状态怎么来的）就可以确定出状态转移方程。

3. 考虑需不需要优化
4. 确定编程实现方式
   1. 递推
   2. 记忆化搜索





## 线性dp

### 习题

#### 方块与收纳盒

链接：https://ac.nowcoder.com/acm/contest/24213/1001
来源：牛客网

**题目描述**                    

​    现在有一个大小n*1的收纳盒，我们手里有无数个大小为1*1和2*1的小方块，我们需要用这些方块填满收纳盒，请问我们有多少种不同的方法填满这个收纳盒 

**输入描述**:

```
第一行是样例数T
第2到2+T-1行每行有一个整数n（n<=80），描述每个样例中的n。
```

**输出描述**:

```
对于每个样例输出对应的方法数
```

**思想&代码**

```c++
#include<bits/stdc++.h>
using namespace std;

long long dp[100];
int T, n;

long long getans(int i)
{
	if(dp[i]!=-1) return dp[i];
	dp[i] = getans(i-1) + getans(i-2);
	return dp[i];
}

int main()
{
	scanf("%d", &T);
	memset(dp, -1, sizeof(dp));
	dp[1] = 1;
	dp[2] = 2;
	getans(80);
	while(T--)
	{
		scanf("%d", &n);
		printf("%lld\n", dp[n]);
	}
	return 0;
}
```

#### 舔狗舔到最后一无所有

链接：https://ac.nowcoder.com/acm/contest/24213/1002
来源：牛客网

**题目描述**                    

作为队伍的核心，forever97很受另外两个队友的尊敬。
 Trote_w每天都要请forever97吃外卖，但很不幸的是宇宙中心forever97所在的学校周围只有3家forever97爱吃的外卖。
 如果Trote_w给forever97买了别家的外卖，forever97就会大喊“我不吃我不吃”。
 但是forever97又不喜欢连续三天吃一种外卖。
 如果Trote_w哪天忘了这件事并且三天给他买了同一家外卖，那么forever97就会把Trote_w的头摁进手机屏幕里。
 作为Trote_w的好朋友，你能告诉他连续请forever97吃n天饭，有多少不同的购买方法吗？

**输入描述**:

```
多组样例
第一行一个整数T(1<=T<=20)代表测试样例数
接下来t行每行一个整数n，代表Trote_w要请forever97吃n天饭(1<=n<=100000)
```

**输出描述**:

```
输出T个整数代表方案数，由于答案太大，你只需要输出mod 1e9+7 后的答案即可。
```

**思想&代码**

用dp\[i\]\[j\]表示第i天点了j号店外卖的情况。

那么可以得到递推式

$dp[i][0] = (dp[i-1][1] + dp[i-1][2] + dp[i-2][1] + dp[i-2][2])$

其中前两项的前一天店号和当前天店号不同，因此不会出现连续三天相同的情况。

后两项是第i-1天与第i天店号相同的情况，那么只需要保证i-2天不是同一家店即可。

dp\[i\]\[1\]和dp\[i\]\[2\]同理。

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e5+100;
const int mod = 1e9+7;

long long dp[maxn][3];
int T;
int n;

int main()
{
	dp[1][0] = 1;
	dp[1][1] = 1;
	dp[1][2] = 1;
	dp[2][0] = 3;
	dp[2][1] = 3;
	dp[2][2] = 3;
	scanf("%d", &T);
	//cacl(100010, 0);
	for(int i=3;i<=100000;i++)
	{
		dp[i][0] = (dp[i-1][1] + dp[i-1][2] + dp[i-2][1] + dp[i-2][2]) % mod;
		dp[i][1] = (dp[i-1][0] + dp[i-1][2] + dp[i-2][0] + dp[i-2][2]) % mod;
		dp[i][2] = (dp[i-1][0] + dp[i-1][1] + dp[i-2][0] + dp[i-2][1]) % mod;
	}
	while(T--)
	{
		scanf("%d", &n);
		printf("%d\n", (dp[n][0] + dp[n][1] + dp[n][2])%mod);
	}
	return 0;
}
```

如果采用递归的方法会爆栈

需要循环递归

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e5+101;
const int mod = 1e9+7;

int dp[maxn][3];
int T;
int n;

int cacl(int x, int y)
{
	if(dp[x][y] != -1) return dp[x][y];
	int ans = 0;
	for(int i=x-2;i<x;i++)
	{
		for(int j=0;j<3;j++)
		{
			dp[x][y] += cacl(i, j);
			dp[x][y] %= mod;
		}
	}
	dp[x][y] += 1;
	dp[x][y] -= (cacl(x-1, y) + cacl(x-2, y));
	while(dp[x][y]<0) dp[x][y] += mod;
	return dp[x][y];
}

int main()
{
	memset(dp, -1, sizeof(dp));
	dp[1][0] = 1;
	dp[1][1] = 1;
	dp[1][2] = 1;
	dp[2][0] = 3;
	dp[2][1] = 3;
	dp[2][2] = 3;
	scanf("%d", &T);
	for(int i=1;i<=1001;i++)
		cacl(100*i, 0);
	while(T--)
	{
		scanf("%d", &n);
		printf("%d\n", ((dp[n][0] + dp[n][1]) % mod + dp[n][2]) % mod);
	}
	return 0;
}
```

考虑递推式的形式，并且3个店具有等效性。

可以将dp降低到一维

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e5+101;
const int mod = 1e9+7;

int dp[maxn];
int T;
int n;


int main()
{
	memset(dp, -1, sizeof(dp));
	dp[1] = 3;
	dp[2] = 9;
	for(int i=3;i<=100000;i++)
	{
		dp[i] = (2 * dp[i-1] % mod + 2 * dp[i-2] % mod) % mod;
	}
	scanf("%d", &T);
	while(T--)
	{
		scanf("%d", &n);
		printf("%d\n", dp[n]);
	}
	return 0;
}
```

递推

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e5+101;
const int mod = 1e9+7;

int dp[maxn];
int T;
int n;

int cacl(int x)
{
	if(dp[x]) return dp[x];
	dp[x] = (2 * cacl(x-1) % mod + 2 * cacl(x-2) % mod) % mod;
	return dp[x];
}

int main()
{
	memset(dp, 0, sizeof(dp));
	dp[1] = 3;
	dp[2] = 9;
	for(int i=1;i<=1000;i++) cacl(100*i);
	scanf("%d", &T);
	while(T--)
	{
		scanf("%d", &n);
		printf("%d\n", dp[n]);
	}
	return 0;
}
```

#### 可爱の星空

链接：https://ac.nowcoder.com/acm/contest/24213/1003
来源：牛客网

**题目描述**                    

  “当你看向她时，有细碎星辰落入你的眼睛，真好。”——小可爱 

  在一个繁星闪烁的夜晚，卿念和清宇一起躺在郊外的草地上，仰望星空。 

  星语心愿，他们，想把这片星空的星星，连成一棵漂亮的树，将这美好的景色记录下来。 

  现在，天上共有n颗星星，编号分别为1,2.....n，一开始任何两个点之间都没有边连接。  

  之后，他们两个想在在(u,v)之间连无向边，需要付出|u联通块大小-v联通块大小|的代价。 

  他们两个想用最少的代价来使这n个点联通，所以他们想知道最小代价是多少。 

  (多组数据 

**输入描述**:

```
第一行一个正整数，表示数据组数T

接下来T行每行一个正整数，表示询问的n
```

**输出描述**:

```
T行，每行一个数表示答案
```

**思想&代码**

对于n结点，最小的连通代价是连通n/2和n/2+n%2两个分量。

观察题目并列举验证前几项，可以发现递推式

$dp[i]  = dp[i] + dp[i/2 + i\%2] + i\%2$

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e5+10;
long long T, n;
long long dp[maxn];

long long cacl(long long n)
{
	if(n<=1e5) return dp[n];
	else return cacl(n/2) + cacl(n/2 + (n&1)) + (n&1);
}

int main()
{
	scanf("%lld", &T);
    dp[0] = 0;
	dp[1] = 0;
	dp[2] = 0;
	for(int i=3;i<=maxn-1;i++)
	{
		dp[i] = dp[i/2] + dp[i/2 + (i&1)] + (i&1);
	}
	while(T--)
	{
		scanf("%lld", &n);
		if(n<=1e5) printf("%lld\n", dp[n]);
		else printf("%lld\n", cacl(n));
	}
	return 0;
}
```

如果用i&1代替i%2，一定注意运算符优先级，i&1要加上括号。

#### 花店橱窗

链接：https://ac.nowcoder.com/acm/contest/24213/1005
来源：牛客网

**题目描述**                    

  小q和他的老婆小z最近开了一家花店，他们准备把店里最好看的花都摆在橱窗里。 

  但是他们有很多花瓶，每个花瓶都具有各自的特点，因此，当各个花瓶中放入不同的花束时，会产生不同的美学效果。 

  为了使橱窗里的花摆放的最合适，他们得想个办法安排每种花的摆放位置。 

  可是因为小q和小z每天都太忙，没有时间设计橱窗里花的摆法，所以他们想让你帮他们求出花摆放的最大美观程度和每种花所放的位置。 

  每种花都有一个标识，假设杜鹃花的标识数为1，秋海棠的标识数为2，康乃馨的标识数为3，所有的花束在放入花瓶时必须保持其标识数的顺序，即： 

  杜鹃花必须放在秋海棠左边的花瓶中，秋海棠必须放在康乃馨左边的花瓶中。 

  如果花瓶的数目大于花束的数目。则多余的花瓶必须空置，且每个花瓶中只能放一束花。 

  每种花放在不同的瓶子里会产生不同的美观程度，美观程度可能是正数也可能是负数。 

  上述例子中，花瓶与花束的不同搭配所具有的美观程度，如下表所示： 

```
花    瓶
                  1     2    3    4    5
   1 (杜鹃花)     7    23   -5  -24   16
   2 (秋海棠)     5    21   -4   10   23
   3 (康乃馨)    -21    5   -4  -20   20
```

  根据上表，杜鹃花放在花瓶2中，会显得非常好看；但若放在花瓶4中则显得十分难看。 

  为取得最大美观程度，你必须在保持花束顺序的前提下，使花束的摆放取得最大的美学值，并求出每种花应该摆放的花瓶的编号。 

**输入描述**:

```
第1行：两个整数F和V，表示共有F种花，V个花瓶。
第2行到第F+1行：每行有V个数，表示花摆放在不同花瓶里的美观程度值value。(美观程度和小于2312^{31}231，美观程度有正有负)
```

**输出描述**:

```
输出有两行：第一行为输出最大美观程度和的值，第二行有F个数表示每朵花应该摆放的花瓶的编号。
若有多种方案，输出字典序较小的方案（美观程度不变的情况下，花尽量往前放）。
```

**思想&代码**

设$dp[i][j]$表示第i个花放在第j个花瓶中的状态。

那么可以得到状态转移方程$dp[i][j] = max(dp[i][k]) + value[i][j]$。其中，$i-1 \le k \le j-1$

注意：

1. dp过程中j的上限。
2. ans只在一维最大值中取。

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 110;
long long value[maxn][maxn];
long long dp[maxn][maxn];
int F, V;
long long ans = 0xf0f0f0f0f0f0f0f0;
int pos[maxn];

int main()
{
	scanf("%d%d", &F, &V);
	for(int i=1;i<=F;i++)
	{
		for(int j=1;j<=V;j++)
		{
			scanf("%lld", &value[i][j]);
		}
	}
	for(int i=1;i<=F;i++)
		for(int j=1;j<=V;j++) dp[i][j] = 0xf0f0f0f0f0f0f0f0;
	for(int i=1;i<=F;i++)
	{
		for(int j=i;j<=V-(F-i);j++)
		{
			for(int k=i-1;k<j;k++)
			{
				dp[i][j] = max(dp[i][j], dp[i-1][k] + value[i][j]);
			}
		}
	}
	for(int j=1;j<=V;j++) ans = max(ans, dp[F][j]);
	printf("%lld\n", ans);
	long long tmp = ans;
	for(int i=F;i>0;i--)
	{
		for(int j=i;j<=V-(F-i);j++)
		{
			if(dp[i][j] == tmp)
			{
				tmp -= value[i][j];
				pos[i] = j;
				break;
			}
		}
	}
	for(int i=1;i<=F;i++) printf("%d ", pos[i]);
	return 0;
}
```

#### 过河卒

链接：https://ac.nowcoder.com/acm/contest/24213/1008
来源：牛客网

**题目描述**                    

  如图，A 点有一个过河卒，需要走到目标 B        点。卒行走规则：可以向下、或者向右。同时在棋盘上的任一点有一个对方的马（如上图的C点），该马所在的点和所有跳跃一步可达的点称为对方马的控制点。例如上图        C 点上的马可以控制 9 个点（图中的P1，P2 … P8 和 C）。卒不能通过对方马的控制点。 

  ![img](https://te4p0t.github.io/assets/images/typora-user-images/202204262300023.gif)  

  棋盘用坐标表示，A 点（0,0）、B 点（n,m）(n,m 为不超过 20        的整数，并由键盘输入)，同样马的位置坐标是需要给出的（约定: C<>A，同时C<>B）。现在要求你计算出卒从 A 点能够到达        B 点的路径的条数。
 **输入描述**:

```
输入B点的坐标（n,m）以及对方马的坐标（X,Y）{不用判错}
```

**输出描述**:

```
输出一个整数（路径的条数）。
```

**思想&代码**

$dp[i][j] = dp[i-1][j] + dp[i][j-1]$

🐎的火力覆盖范围手动赋0

tips:

- 要开long long
- 左侧和上侧边界不能初始化赋值1，因为若边界存在点在🐎的火力范围内，后继点方案数均为0。

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 30;
int n, m, x, y;
long long dp[maxn][maxn];
int dir[8][2] = {1, 2, -1, 2, 1, -2, -1, -2, 2, 1, 2, -1, -2, 1, -2, -1};

bool inmap(int x, int y)
{
	return x>=1 && x<=n+1 && y>=1 && y<=m+1;
}

long long getans(int x, int y)
{
	if(dp[x][y]>=0) return dp[x][y];
	dp[x][y] = getans(x-1, y) + getans(x, y-1);
	return dp[x][y];
}

int main()
{
	memset(dp, -1, sizeof(dp));
	scanf("%d%d%d%d", &n, &m, &x, &y);
	for(int i=0;i<=m+1;i++) dp[0][i] = 0;
	for(int j=0;j<=n+1;j++) dp[j][0] = 0;
	dp[1][1] = 1;
	for(int i=0;i<8;i++)
		if(inmap(x+1+dir[i][0], y+1+dir[i][1]))
			dp[x+1+dir[i][0]][y+1+dir[i][1]] = 0;
	dp[x+1][y+1] = 0;
	printf("%lld", getans(n+1, m+1));
	// cout << endl;
	// for(int i=0;i<=n+1;i++)
	// {
		// for(int j=0;j<=m+1;j++)
		// {
			// printf("%4lld", dp[i][j]);
		// }
		// cout <<endl;
	// }
	return 0;
}
```

#### 传球游戏

链接：https://ac.nowcoder.com/acm/contest/24213/1009
来源：牛客网

**题目描述**                    

上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。
 游戏规则是这样的：n个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没传出去的那个同学就是败者，要给大家表演一个节目。
 聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了m次以后，又回到小蛮手里。两种传球的方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有3个同学1号、2号、3号，并假设小蛮为1号，球传了3次回到小蛮手里的方式有1->2->3->1和1->3->2->1，共2种。

**输入描述**:

```
共一行，有两个用空格隔开的整数n，m（ 3 ≤ n ≤ 30，1 ≤ m ≤ 30 ）。
```

**输出描述**:

```
共一行，有一个整数，表示符合题意的方法数。
```

**思想&代码**

$dp[i][j]$表示第i次球传到第j人手中的方案数

$dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]$，注意j在边界时特判j-1和j+1。

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 35;
long long dp[maxn][maxn];
int vis[maxn][maxn];
int n, m;

long long getans(int x, int y)
{
	//cout << x << ' ' << y << endl;
	if(vis[x][y]) return dp[x][y];
	int zuo = y-1, you = y+1;
	if(zuo<1) zuo = n;
	if(you>n) you = 1;
	//cout << ' ' <<zuo << ' ' <<you << endl;
	dp[x][y] = getans(x-1, zuo) + getans(x-1, you);
	//cout << dp[x][y] << endl;
	vis[x][y] = 1;
	return dp[x][y];
}

int main()
{
	memset(dp, 0, sizeof(dp));
	memset(vis, 0, sizeof(vis));
	scanf("%d%d", &n, &m);
	dp[0][1] = 1;
	vis[0][1] = 1;
	for(int i=2;i<=n;i++) vis[0][i] = 1;
	for(int i=1;i<=n;i++) getans(m, i);
	printf("%lld", getans(m, 1));
	cout <<endl;
	// for(int i=0;i<=m;i++)
	// {
		// for(int j=1;j<=n;j++)
		// {
			// printf("%4lld", dp[i][j]);
		// }
		// cout << endl;
	// }
	return 0;
}
```

#### 「木」迷雾森林

链接：https://ac.nowcoder.com/acm/contest/24213/1010
来源：牛客网

**题目描述**                    

  赛时提示：保证出发点和终点都是空地 

  帕秋莉掌握了一种木属性魔法 

  这种魔法可以生成一片森林（类似于迷阵），但一次实验时，帕秋莉不小心将自己困入了森林 

  帕秋莉处于地图的左下角，出口在地图右上角，她只能够向上或者向右行走 

  现在给你森林的地图，保证可以到达出口，请问有多少种不同的方案 

  答案对2333取模 

**输入描述**:

```
第一行两个整数m , n表示森林是m行n列
接下来m行，每行n个数，描述了地图
0  -  空地
1  -  树（无法通过）
```

**输出描述**:

```
一个整数表示答案
```

**思想&代码**

和过河卒同样的思路

```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 3010;
int n, m;
int a[maxn][maxn];
long long dp[maxn][maxn];
int vis[maxn][maxn];


template<class T>inline void read(T &res)
{
char c;T flag=1;
while((c=getchar())<'0'||c>'9')if(c=='-')flag=-1;res=c-'0';
while((c=getchar())>='0'&&c<='9')res=res*10+c-'0';res*=flag;
}


long long getans(int x, int y)
{
	if(vis[x][y]) return dp[x][y];
	long long zuo=0, shang=0;
	if(y-1 != 0) zuo = getans(x, y-1);
	if(x-1 != 0) shang = getans(x-1, y);
	dp[x][y] = zuo + shang;
	vis[x][y] = 1;
	return dp[x][y];
}

int main()
{
	memset(dp, 0, sizeof(dp));
	memset(vis, 0, sizeof(vis));
	dp[1][1] = 1;
	vis[1][1] = 1;
	for(int i=0;i<=n;i++) vis[0][i] = 1;
	for(int i=0;i<=m;i++) vis[i][0] = 1;
	read(n);
	read(m);
	for(int i=m;i>0;i--)
	{
		for(int j=1;j<=n;j++)
		{
			read(a[i][j]);
			if(a[i][j]==1) vis[i][j]=1;
		}
	}
	printf("%lld", getans(m, n));
	return 0;
}
```

#### [NOIP2004]合唱队形

链接：https://ac.nowcoder.com/acm/problem/16664
来源：牛客网

**题目描述**                    

  N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。  

  合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1，2…，K，他们的身高分别为T1，T2，…，TK， 则他们的身高满足T1<...<Ti>Ti+1>…>TK(1<=i<=K)。  

  你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。  

**输入描述**:

```
输入的第一行是一个整数N(2<=N<=100)，表示同学的总数。第一行有n个整数，用空格分隔，第i个整数Ti(130<=Ti<=230)是第i位同学的身高(厘米)。
```

**输出描述**:

```
输出包括一行，这一行只包含一个整数，就是最少需要几位同学出列。
```

**思想&代码**

最长上升子序列改进版

$dp[i] = max(dp[k]) + 1$, k小于i且h[k]小于h[i]。

求一遍最长上升子序列，再同理求最长下降子序列

结果$N-max(dp[i]+dp2[i]-1)$

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 110;
int dp[maxn];
int dp2[maxn];
int N;
int h[maxn];
int ans = 0;

int getans(int x)
{
	if(dp[x]>=0) return dp[x];
	for(int i=0;i<x;i++)
	{
		getans(i);
		if(h[i]<h[x]) dp[x] = max(dp[i]+1, dp[x]);
	}
	return dp[x];
}

int getans2(int x)
{
	if(dp2[x]>=0) return dp2[x];
	for(int i=x+1;i<=N+1;i++)
	{
		getans2(i);
		if(h[i]<h[x]) dp2[x] = max(dp2[i]+1, dp2[x]);
	}
	return dp2[x];	
}

int main()
{
	memset(dp, -1, sizeof(dp));
	memset(dp2, -1, sizeof(dp2));
	dp[0] = 0;
	h[0] = 0;
	scanf("%d", &N);
	h[N+1] = 0;
	dp2[N+1] = 0;
	for(int i=1;i<=N;i++) scanf("%d", &h[i]);
	getans(N);
	getans2(1);
	//for(int i=1;i<=N;i++) cout << dp2[i] <<' ';
	//cout << endl;
	for(int i=1;i<=N;i++)
	{
		ans = max(ans, dp[i]+dp2[i]-1);
	}
	printf("%d", N-ans);
	return 0;
}
```



#### 免费馅饼

链接：https://ac.nowcoder.com/acm/contest/24213/1006
来源：牛客网

**题目描述**                    

   SERKOI最新推出了一种叫做“免费馅饼”的游戏:游戏在一个舞台上进行。舞台的宽度为W格，天幕的高度为H格，游戏者占一格。开始时游戏者站在舞台的正中央，手里拿着一个托盘。下图为天幕的高度为4格时某一个时刻游戏者接馅饼的情景。 

  ![img](https://te4p0t.github.io/assets/images/typora-user-images/202204262301948.png)


   游戏开始后，从舞台天幕顶端的格子中不断出现馅饼并垂直下落。游戏者左右移动去接馅饼。游戏者每秒可以向左或向右移动一格或两格，也可以站在原地不动。
 馅饼有很多种，游戏者事先根据自己的口味，对各种馅饼依次打了分。同时，在8-308电脑的遥控下，各种馅饼下落的速度也是不一样的，下落速度以格/秒为单位。
 当馅饼在某一秒末恰好到达游戏者所在的格子中，游戏者就收集到了这块馅饼。
 写一个程序，帮助我们的游戏者收集馅饼，使得所收集馅饼的分数之和最大。  

**输入描述**:

```
第一行是用空格隔开的两个正整数，分别给出了舞台的宽度W（1到99之间的奇数）和高度H（1到100之间的整数）。
接下来依馅饼的初始下落时间顺序给出了所有馅饼的信息。每一行给出了一块馅饼的信息。由四个正整数组成，分别表示了馅饼的初始下落时刻（0到1000秒），水平位置、下落速度（1到100）以及分值。游戏开始时刻为0。从1开始自左向右依次对水平方向的每格编号。
输入文件中同一行相邻两项之间用一个或多个空格隔开
```

**输出描述**:

```
第一行给出了一个正整数，表示你的程序所收集的最大分数之和。
其后的每一行依时间顺序给出了游戏者每秒的决策。输出0表示原地不动、1或2表示向右移动一步或两步、-1 或-2表示向左移动一步或两步。输出应持续到游戏者收集完他要收集的最后一块馅饼为止
```

**思想&代码**

首先对每块馅饼的数据进行转换，转换到二维数组value上

其中value\[i\]\[j\]表示在第i秒下降到（1，j）该位置处的馅饼的分数总和。

设dp\[i\]\[j\]表示第i秒在第j个位置所能够得到的最大分数之和。

$dp[i][j] = max(dp[i-1][k])+value[i][j], j-2\le k \le j+2$

```c++
```





****

### 待完成

NC 105685 poj1088 滑雪

最大子串和

NC 106055 poj1458 最长公共子序列



## 背包

### 01背包

**思想&代码**

$dp[i][j]$表示第i个物品装满j空间大小所能得到的价值

$dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+value[i])$

**N<=20, V<=10^9**

背包体积太大，但物品数较小，直接暴力枚举

**N<=40, V<=10^9**

整体二分拼接答案

**N<=100, V<=10^9**

用map映射体积



**完全背包**

在01背包的基础上每个物品有无数件供选择。

**思想&代码**

$dp[i][j]$仍然表示第i个物品恰好放入一个容量为v的背包的最大价值

在每次循环的过程中加一个对i件物品遍历个数的循环。

$dp[i][j] = max(dp[i-1][j-k*w[i]]+k*v[i]), 0\le k*w[i]\le j$

时间复杂度为$O(V*\sum(\frac{V}{c[i]}))$

但只是这样的话绝大部分题过不去

考虑到在01背包就地滚动的任务中，循环如果保持正序就会出现将同一个物品计算多次的情况，完全适用于完全背包问题，因此可以直接借鉴过来。

因此解决完全背包的方法：就地滚动+内循环正序

### 多重背包

有N种物品和一个容量为V的背包。第i种物品最多有n\[i\]件可用，每件费用（体积）是w\[i\]，价值是v\[i\]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

**思想&代码**

最朴素的状态转移方程和完全背包一样

$dp[i][j] = max\{dp[i][j-k*w[i]]+k*v[i] | 0\le k\le n[i]\}$

复杂度是$O(V*\sum{n[i]})$，比较大，需要优化。

**优化**

数字的二进制拆分

- 转化为01背包求解：把第i中物品换成n\[i\]件0背包中的物品，则得到了物品数为$\sum{n[i]}$的01背包问题
- 当然这样直接求解的复杂度仍然是$O(V*\sum {n[i]})$
- 我们考虑把第i种物品换成若干件物品，使得原问题中第i中物品可取的每种策略——取0...n\[i\]件——均能等价于取若干件代换以后的物品。另外，取超过n\[i\]件的策略必不能出现
- 方法是：将第i中物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为**1, 2, 4, ..., 2^(k-1), n\[i\]-2^k+1，且k是满足n\[i\]-2^k+1>0的最大整数。例如，如果n\[i\]为13，九江这种物品分成系数分别为1,2,4,6的四件物品。

原理

1. $1+2+4+...+2^{k-1}+n[i]-2^k+1=n[i]$这就保证了最多为n\[i\]个物品
2. $1,2,4,...,2^{k-1}$可以凑出1到$2^{k}-1$的所有整数（联系一个数的二进制拆分即可证明）
3. $2^{k}...n[i]$的所有整数可以用若干上述元素凑出（可以理解为凑n\[i\]-t，而n\[i\]为上面所有数的和，t则是一个小于$2^k$的数，那么在所有的数中去掉组成$2^k$的那些数剩下的就可以组成n\[i\]-t了）

这样优化后复杂度为$O(V*\sum{\log{n[i]}})$

### 二维费用的背包问题

二维费用的背包问题是指：对于每件物品，具有两种不同的费用。选择这件物品必须同时付出这两种代价。对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i减物品所需的两种代价分别为a\[i\]和b\[i\]。两种代价客服处的最大值（两种背包容量）分别为V和U。物品的价值为w\[i\]。

**思想&代码**

设$dp[i][v][u]$表示前i件物品付出两种代价分别为v和时可获得的最大价值。状态转移方程就是

$dp[i][v][u] = max{dp[i-1][v][u], dp[i-1][v-a[i]][u-b[i]]+value[i]}$

**当你发现题目是由熟悉的动态规划题目添加了限制条件变形得来的时候，可以尝试在原题的状态中加一维以满足新的限制条件**

### 分组背包

有N件物品和一个容量为V的背包。第i件物品的费用是c\[i\]，价值是value\[i\]。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

本题和前面的题最大的不同是——每组物品有若干中策略：选择本组的某一件，或者一件都不选。

**思想&代码**

$dp[k][v]$表示前k组物品花费费用v能取得的最大值。

$dp[k][v]=max{dp[k-1][v], dp[k-1][v-c[i]]+value[i]}|物品i属于组k$

使用一维数组伪代码如下

```c++
for 所有的组k
    for v=V...0
        for 所有的i属于k
            dp[v] = max{f[v], f[v-c[i]+w[i]]}
```

```for v=V...0```这一层循环必须在```for 所有的i属于组k```之外。这样才能保证每一组内的物品最多只有一个会被添加到背包中。

### 习题

#### NC 16693 装箱问题

链接：https://ac.nowcoder.com/acm/problem/16693
来源：牛客网

**题目描述**                    

有一个箱子容量为V（正整数，0 ≤ V ≤ 20000），同时有n个物品（0＜n ≤ 30），每个物品有一个体积（正整数）。
 要求n个物品中，任取若干个装入箱内，使箱子的剩余空间为最小。

**输入描述**:

```
1个整数，表示箱子容量
1个整数，表示有n个物品
接下来n行，分别表示这n个物品的各自体积
```

**输出描述**:

```
1个整数，表示箱子剩余空间。
```

**思想&代码**

$dp[i][j]$表示第i个物品时能否恰好填满j空间的大小。

$dp[i][j] = dp[i-1][j] || dp[i-1][j-v[i]]$

$dp[0][0]=1$

- 可以0 1滚动 || 就地滚动优化空间复杂度

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxv = 20010;
const int maxn = 40;
int n, V;
int a[maxn];
int dp[maxn][maxv];


int main()
{
	scanf("%d%d", &V, &n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d", &a[i]);
	}
	memset(dp, 0, sizeof(0));
	dp[0][0] = 1;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=V;j++)
		{
			if(j<a[i]) dp[i][j] = dp[i-1][j];
			else dp[i][j] = dp[i-1][j] || dp[i-1][j-a[i]];
		}
	}
	int ans = 0;
	for(int i=V;i>=0;i--)
	{
		if(dp[n][i]==1)
		{
			ans = i;
			break;
		}
	}
	printf("%d", V-ans);
	return 0;
}
```

01滚动

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxv = 20010;
const int maxn = 40;
int n, V;
int a[maxn];
int dp[2][maxv];


int main()
{
	scanf("%d%d", &V, &n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d", &a[i]);
	}
	memset(dp, 0, sizeof(0));
	dp[0][0] = 1;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=V;j++)
		{
			if(j<a[i]) dp[i%2][j] = dp[(i-1)%2][j];
			else dp[i%2][j] = dp[(i-1)%2][j] || dp[(i-1)%2][j-a[i]];
		}
	}
	int ans = 0;
	for(int i=V;i>=0;i--)
	{
		if(dp[n%2][i]==1)
		{
			ans = i;
			break;
		}
	}
	printf("%d", V-ans);
	return 0;
}
```

就地滚动

注意dp过程中内循环的j需要从大到小遍历，否则在一次遍历过程中会将当前物品算n次。

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxv = 20010;
const int maxn = 40;
int n, V;
int a[maxn];
int dp[maxv];


int main()
{
	scanf("%d%d", &V, &n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d", &a[i]);
	}
	memset(dp, 0, sizeof(0));
	dp[0] = 1;
	for(int i=1;i<=n;i++)
	{
		for(int j=V;j>=a[i];j--)
		{
			dp[j] = dp[j] || dp[j-a[i]];
		}
	}
	int ans = 0;
	for(int i=V;i>=0;i--)
	{
		if(dp[i]==1)
		{
			ans = i;
			break;
		}
	}
	printf("%d", V-ans);
	return 0;
}
```

#### CSL分苹果

链接：https://ac.nowcoder.com/acm/problem/17871
来源：牛客网

**题目描述**                    

CSL手上有n个苹果，第i个苹果的质量是wi，现在他想把这些苹果分给他的好朋友wavator和tokitsukaze。但是CSL为了不让他们打架，根据质量决定尽量地均分成两堆分给他们。现在CSL想知道到底给每个人分多少质量的苹果。

 注意：苹果不能劈开来，并且如果不能正好均分，tokitsukaze小姐姐会拿到重的那一堆。

**输入描述**:

```
第一行输入一个整数n(2 ≤ n ≤ 100)，第二行n个整数，表示每个苹果的质量wi(1 ≤ wi ≤ 100)。
```

**输出描述**:

```
输出两个整数，分别表示wavator和tokitsukaze得到的苹果的质量。
```

**思想&代码**

刚开始的想法是

用dp\[i\]\[j\]表示在分了第i个苹果后，两人相差j的重量。此处的j取10010+实际重量的做法来避免数组中的负数。

这样$dp[i][j] = dp[i-1][k\pm w[i]]$，其中$0 \le k \le 20000$且$dp[i-1][k]=1$

最后从10010开始向两端搜（其实向一端搜即可），这样勉强能过。

```c++
#include<bits/stdc++.h>
using namespace std;

int dp[110][200020];
int n;
int w[110];
int sum=0;

int main()
{
	memset(dp, 0, sizeof(dp));
	scanf("%d", &n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d", &w[i]);
		sum += w[i];
	}
	dp[0][10010] = 1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=20000;j++)
		{
			if(dp[i-1][j]==1)
			{
				dp[i][j+w[i]] = 1;
				dp[i][j-w[i]] = 1;
			}
		}
	}
	int ans=0;
	for(int i=0;i<=10000;i++)
	{
		if(dp[n][10010+i]==1 || dp[n][10010-i]==1)
		{
			ans = i;
			break;
		}
	}
	printf("%d %d", (sum-ans)/2, (sum+ans)/2);
	return 0;
}
```

之后发现蠢了。这个题实际上就是以sum>>1为上界的背包问题。

```c++
#include<bits/stdc++.h>
using namespace std;

int dp[110][10010];
int n;
int w[110];
int sum=0;

int main()
{
	memset(dp, 0, sizeof(dp));
	scanf("%d", &n);
	for(int i=1;i<=n;i++)
	{
		scanf("%d", &w[i]);
		sum += w[i];
	}
	dp[0][0] = 1;
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=(sum>>1);j++)
		{
			if(j<w[i]) dp[i][j] = dp[i-1][j];
			if(j>=w[i]) dp[i][j] = dp[i-1][j-w[i]] || dp[i-1][j];
		}
	}
	int ans=0;
	for(int i=(sum>>1);i>=0;i--)
	{
		if(dp[n][i]==1)
		{
			ans = i;
			break;
		}
	}
	printf("%d %d", ans, sum-ans);
	return 0;
}
```

#### [NOIP]采药

链接：https://ac.nowcoder.com/acm/contest/24213/1018
来源：牛客网

**题目描述**                    

  辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”   

  如果你是辰辰，你能完成这个任务吗？  

**输入描述**:

```
第一行有两个整数T（1<=T<=1000）和M（1<=M<=100），用一个空格隔开，T代表总共能够用来采药的时间，M代表山洞里的草药的数目。
接下来的M行每行包括两个在1到100之间（包括1和100）的整数，分别表示采摘某株草药的时间和这株草药的价值。
```

**输出描述**:

```
包括一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。
```

**思想&代码**

01背包版子题

$dp[i][j]$表示j时间内采i个药品的最大总价值

$dp[i][j] = max\{dp[i-1][j], dp[i-1][j-t[i]]+v[i]\}$

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxt = 1010;
const int maxn = 110;

int v[maxn], t[maxn];
int dp[maxn][maxt];
int T, M;

int main()
{
	scanf("%d%d", &T, &M);
	for(int i=1;i<=M;i++)
	{
		scanf("%d%d", &t[i], &v[i]);
	}
	dp[0][0] = 0;
	for(int i=1;i<=M;i++)
	{
		for(int j=0;j<=T;j++)
		{
			if(j<t[i]) dp[i][j] = dp[i-1][j];
			else
			{
				dp[i][j] = max(dp[i-1][j], dp[i-1][j-t[i]] + v[i]);
			}
		}
	}
	printf("%d", dp[M][T]);
	return 0;
}
```

#### [NOIP]开心的金明

链接：https://ac.nowcoder.com/acm/contest/24213/1019
来源：牛客网

**题目描述**                    

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过N元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的N元。于是，他把每件物品规定了一个重要度，分为5等：用整数1~5表示，第5等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过N元（可以等于N元）的前提下，使每件物品的价格与重要度的乘积的总和最大。
 设第j件物品的价格为v[j]，重要度为w[j]，共选中了k件物品，编号依次为j1，j2，……，jk，则所求的总和为：
 v[j1]*w[j1]+v[j2]*w[j2]+ …+v[jk]*w[jk]。（其中*为乘号）
 请你帮助金明设计一个满足要求的购物单。

**输入描述**:

```
输入第1行，为两个正整数，用一个空格隔开：N m（其中N表示总钱数，m为希望购买物品的个数。）
从第2行到第m+1行，第j行给出了编号为j-1的物品的基本数据，每行有2个非负整数v p（其中v表示该物品的价格，p表示该物品的重要度）
```

**输出描述**:

```
输出一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（<100000000）
```

**思想&代码**

01背包

价值改为重要度和价值的乘积即可。

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxt = 30010;
const int maxn = 30;

int p[maxn], v[maxn];
int dp[maxn][maxt];
int N, m;

int main()
{
	scanf("%d%d", &N, &m);
	for(int i=1;i<=m;i++)
	{
		scanf("%d%d", &v[i], &p[i]);
		p[i] *= v[i];
	}
	dp[0][0] = 0;
	for(int i=1;i<=m;i++)
	{
		for(int j=0;j<=N;j++)
		{
			if(j<v[i]) dp[i][j] = dp[i-1][j];
			else
			{
				dp[i][j] = max(dp[i-1][j], dp[i-1][j-v[i]] + p[i]);
			}
		}
	}

	printf("%d", dp[m][N]);
	return 0;
}
```

#### 失衡天平

链接：https://ac.nowcoder.com/acm/contest/24213/1021
来源：牛客网

**题目描述**                    

终于Alice走出了大魔王的陷阱，可是现在傻傻的她忘了带武器了，这可如何是好???这个时候，一个神秘老人走到她面前答应无偿给她武器，但老人有个条件，需要将所选武器分别放在天平的两端，若天平平衡则可以将天平上的所有武器拿走，还好这个天平锈迹斑斑，只要两端重量相差小于等于m就会保持平衡，Alice傻傻的认为越重的武器越好，求Alice最多能拿走的武器总重量。（不限操作次数）

**输入描述**:

```
第一行2个整数 n, m;
第二行n个整数x，分别表示n件武器的重量。
1 <= n <= 100; 0 <= m <= 100; 1 <= x <= 100;
```

**输出描述**:

```
一个整数，表示Alice最多能拿走的武器总重量。
```

**思想&代码**

带走最多次数的方案，无论是分多少次操作，总能合并为一次操作带走。

因此$dp[i][j]$表示第i个物品天平相差j重量的情况下所能拿到的武器的最大总重量。

$dp[i][j] = max\{dp[i-1][j], dp[i-1][abs(j-w[i])]+w[i], dp[j+w[i]]+w[i] \}$

加上的绝对值在排除掉负值的情况下不影响结果，因为天平两边是等价的，负数取绝对值相当于天平左右物品互换。

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxw = 10010;
const int maxn = 110;

int n, m, sum=0, ans = 0;
int dp[maxn][maxw];
int w[maxn];

int main()
{
	scanf("%d%d", &n, &m);
	for(int i=1;i<=n;i++)
	{
		scanf("%d", &w[i]);
		sum += w[i];
	}
	memset(dp,-0x3f,sizeof(dp));
	dp[0][0] = 0;
	
	for(int i=1;i<=n;i++)
	{
		for(int j=0;j<=sum;j++)
		{
			dp[i][j] = max(dp[i-1][j], dp[i-1][abs(j-w[i])]+w[i]);
			dp[i][j] = max(dp[i][j], dp[i-1][j+w[i]]+w[i]);
		}
	}
	int ans = 0;
	for(int i=0;i<=m;i++) ans = max(ans, dp[n][i]);
	printf("%d", ans);
	return 0;
}
```

#### Music Problem

链接：https://ac.nowcoder.com/acm/problem/13885
来源：牛客网

**题目描述**                    

 Listening to the music is relax, but for obsessive(强迫症), it may be unbearable. 

 HH is an obsessive, he only start to listen to music at 12:00:00, and he will never stop unless the song he is listening ends at integral points (both minute and second are 0 ), that is, he can stop listen at 13:00:00 or 14:00:00,but he can't stop at 13:01:03 or 13:01:00, since 13:01:03 and 13:01：00 are not an integer hour time. 

 Now give you the length of some songs, tell HH whether it's possible to choose some songs so he can stop listen at an integral point, or tell him it's impossible. 

 Every song can be chosen at most once. 

**输入描述**:

```
 The first line contains an positive integer T(1≤T≤60), represents there are T test cases. 
 For each test case: 
 The first line contains an integer n(1≤n≤105), indicating there are n songs. 
 The second line contains n integers a1,a2…an (1≤ai≤109 ), the ith integer ai indicates the ith song lasts ai seconds.
```

**输出描述**:

```
For each test case, output one line "YES" (without quotes) if HH is possible to stop listen at an integral point, and "NO" (without quotes) otherwise.
```

**思想&代码**

令$dp[i][j]$表示第i首歌，所需时间j，其中j为取余3600后的数。

$dp[i][j] = d[i-1][j]|dp[i-1][(j-h[i]+3600)\%3600]$

但这样复杂度$O(T*N*3600)$太大。

考虑鸽巢原理，当N>=3600时，必定存在一种组合，使得N个数相加的和模3600值为0。

因此可将复杂度优化到$O(T*3600*3600)$，这个复杂度可以过。

tips:

- 在这道题处理的过程中，不可以将$dp[0][0]$初始化为1，

```c++
#include<bits/stdc++.h>
using namespace std;
 
const int maxn = 1e5+10;
const int maxt = 3700;
bool dp[maxt][maxt];
int a[maxn];
int T, n;
 
int main()
{
    scanf("%d", &T);
    while(T--)
    {
        memset(dp, 0, sizeof(dp));
        scanf("%d", &n);
        for(int i=1;i<=n;i++)
        {
            scanf("%d", &a[i]);
            a[i] %= 3600;
        }
        if(n>=3600)
        {
            printf("YES\n");
            continue;
        }
        for(int i=1;i<=n;i++)
        {
        	if(i!=1) dp[i-1][a[i-1]] = 1;
            for(int j=0;j<=3599;j++)
            {
                dp[i][j] = dp[(i-1)][j] | dp[(i-1)][(j-a[i]+3600)%3600];
            }
        }
        dp[n][a[n]] = 1;
        if(dp[n][0]==1) printf("YES\n");
        else printf("NO\n");
    }
    return 0;
}
```





### 区间dp

#### 待完成

**括号匹配**

**最长回文子序列长度**

$f[i][j]$表示$a_i……a_j$的串中，最长回文子序列长度

如果$a_i$与$a_j$是一样的$f[i][j] = f[i+1][j-1]+2$

否则$f[i][j]=max(f[i+1][j], f[i][j-1])$

**最长回文子串长度**



**NC 106884 POJ2287 田忌赛马**





### 习题

#### 沙堆合并

链接：https://ac.nowcoder.com/acm/contest/24213/1031
来源：牛客网

**题目描述**                    

设有N堆沙子排成一排，其编号为1，2，3，…，N1，2，3，\dots ，N1，2，3，…，N（N≤300）（N\leq 300）（N≤300）。每堆沙子有一定的数量，可以用一个整数来描述，现在要将这N堆沙子合并成为一堆，每次只能合并相邻的两堆，合并的代价为这两堆沙子的数量之和，合并后与这两堆沙子相邻的沙子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同，如有4堆沙子分别为 1  3  5  2 我们可以先合并1、2堆，代价为4，得到4 5 2 又合并 1，2堆，代价为9，得到9 2 ，再合并得到11，总代价为4+9+11=24，如果第二步是先合并2，3堆，则代价为7，得到4 7，最后一次合并代价为11，总代价为4+7+11=22；问题是：找出一种合理的方法，使总的代价最小。输出最小代价。

**输入描述**:

```
第一行一个数N表示沙子的堆数N。
第二行N个数，表示每堆沙子的质量(≤1000)(\leq1000)(≤1000)。
```

**输出描述**:

```
合并的最小代价
```

**思想&代码**

弱化版石子合并

```c++
#include<bits/stdc++.h>
using namespace std;
#define INF 0x3f3f3f3f

const int maxn = 410;

int dp2[maxn][maxn];
int n, a[maxn], sum[maxn];
int minn = INF;

int getans2(int i, int j)
{
	if(dp2[i][j]>=0) return dp2[i][j];
	dp2[i][j] = INF;
	for(int k=i;k<j;k++)
	{
		dp2[i][j] = min(dp2[i][j], getans2(i, k)+getans2(k+1, j)+sum[j]-sum[i-1]);
	}
	return dp2[i][j];
}

int main()
{
	memset(dp2, -0x3f, sizeof(dp2));
	scanf("%d", &n);
	for(int i=1;i<=n;i++) {dp2[i][i] = 0;}
	for(int i=1;i<=n;i++)
	{
		scanf("%d", &a[i]);
		sum[i] = sum[i-1] + a[i];
	}
	minn = getans2(1, n);
	printf("%d", minn);
	return 0;
}
```



#### NC 50493 石子合并

链接：https://ac.nowcoder.com/acm/contest/24213/1030
来源：牛客网

**题目描述**                    

将n堆石子绕圆形操场排放，现要将石子有序地合并成一堆。规定每次只能选相邻的两堆合并成新的一堆，并将新的一堆的石子数记做该次合并的得分。
 请编写一个程序，读入堆数n及每堆的石子数，并进行如下计算：

1. ​    选择一种合并石子的方案，使得做n-1次合并得分总和最大。   
2. ​    选择一种合并石子的方案，使得做n-1次合并得分总和最小。   

**输入描述**:

```
输入第一行一个整数n，表示有n堆石子。
第二行n个整数，表示每堆石子的数量。
```

**输出描述**:

```
第一行为合并得分总和最小值，
第二行为合并得分总和最大值。
```

先考虑没有环的情况：

$f[i][j]$表示**合并i到j的所有石子的得分**

$f[i][j] = max\{f[i][j], f[i][k]+f[k+1][j]+sum[i][j] \}$

$sum[i][j]$表示i到j的式子的价值和（也可以前缀和实现$sum[i]$表示前i个石子的价值，那么我们需要的就是$sum[j]-sum[i-1]$）

但是现在有环，可以通过取模的方法把它变成循环的。

也可以将序列加倍：变成'12341234'，就可以完全用链的方法解决了。

边界：$f[i][i]=0$

```c++
#include<bits/stdc++.h>
using namespace std;
#define INF 0x3f3f3f3f

const int maxn = 410;

int dp[maxn][maxn], dp2[maxn][maxn];
int n, a[maxn], sum[maxn];
int maxx = -INF, minn = INF;

int getans(int i, int j)
{
	if(dp[i][j]>=0) return dp[i][j];
	for(int k=i;k<j;k++)
	{
		dp[i][j] = max(dp[i][j], getans(i, k)+getans(k+1, j)+sum[j]-sum[i-1]);
	}
	//cout << i << ' ' << j <<' ' << dp[i][j]<< endl;
	return dp[i][j];
}

int getans2(int i, int j)
{
	if(dp2[i][j]>=0) return dp2[i][j];
	dp2[i][j] = INF;
	for(int k=i;k<j;k++)
	{
		dp2[i][j] = min(dp2[i][j], getans2(i, k)+getans2(k+1, j)+sum[j]-sum[i-1]);
	}
	//cout << i << ' ' << j <<' ' << dp2[i][j]<< endl;
	return dp2[i][j];
}

int main()
{
	memset(dp, -0x3f, sizeof(dp));
	memset(dp2, -0x3f, sizeof(dp2));
	scanf("%d", &n);
	for(int i=1;i<=2*n;i++) {dp[i][i] = 0; dp2[i][i] = 0;}
	for(int i=1;i<=n;i++)
	{
		scanf("%d", &a[i]);
		sum[i] = sum[i-1] + a[i];
	}
	for(int i=n+1;i<2*n;i++)
	{
		a[i] = a[i-n];
		sum[i] = sum[i-1] + a[i];
	}
	for(int i=1;i<=n;i++)
	{
		maxx = max(maxx, getans(i, i+n-1));
		minn = min(minn, getans2(i, i+n-1));
	}
	printf("%d\n%d", minn, maxx);
	return 0;
}
```

#### 凸多边形的划分

链接：https://ac.nowcoder.com/acm/contest/24213/1036
来源：牛客网

**题目描述**                    

给定一个具有N个顶点的凸多边形，将顶点从1至N标号，每个顶点的权值都是一个正整数。将这个凸多边形划分成N-2个互不相交的三角形，试求这些三角形顶点的权值乘积和至少为多少。

**输入描述**:

```
输入第一行为顶点数N
第二行依次为顶点1至顶点N的权值。
```

**输出描述**:

```
输出仅一行，为这些三角形顶点的权值乘积和的最小值。
```

**思想&代码**

设$f[i][j](i<j)$表示从顶点i到顶点j的凸多边形三角剖分后所得到的最大乘积，我们可以得到下面的动态转移方程

$f[i][j] = min\{f[i][k]+f[k][j]+s[i]*s[j]*s[k](i<k<j) \}$

显然目标状态为$f[1][n]$

tips:

- 记忆化搜索会爆内存

- 答案结果会很大，需要高精，__int128模板

```c++
#include<bits/stdc++.h>
using namespace std;
typedef __int128 ll;
const int maxn = 55;
__int128 dp[maxn][maxn];
__int128 s[maxn];

inline __int128 read()
{
    __int128 x=0,f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9')
    {
        if(ch=='-')
            f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9')
    {
        x=x*10+ch-'0';
        ch=getchar();
    }
    return x*f;
}

inline void write(__int128 x)
{
    if(x<0)
    {
        putchar('-');
        x=-x;
    }
    if(x>9)
        write(x/10);
    putchar(x%10+'0');
}

ll getans(int i, int j)
{
	if(dp[i][j]>=0) return dp[i][j];
	dp[i][j] = 1e30;
	for(int k=i;k<=j;k++)
	{
		dp[i][j] = min(dp[i][j], getans(i, k) + getans(k, j) + s[i]*s[j]*s[k]);
	}
	//cout << i << ' ' << j << ' ' << dp[i][j] <<endl;
	return dp[i][j];
}

int main()
{
	int N;
	scanf("%d", &N);
	for(int i=1;i<=N;i++) s[i] = read();
	for(int l=2;l<=N-1;l++)
	{
		for(int i=1;i<=N-l;i++)
		{
			dp[i][i+l] = 1e35;
			for(int k=i;k<=i+l;k++)
			{
				dp[i][i+l] = min(dp[i][i+l], dp[i][k]+dp[k][i+l]+s[i]*s[i+l]*s[k]);
			}
		}
	}
	write(dp[1][N]);
	return 0;
}
```



#### 简单瞎搞题

链接：https://ac.nowcoder.com/acm/contest/24213/1035
来源：牛客网

**题目描述**                    

  一共有 n个数，第 i 个数是 xi 

  xi 可以取 [li , ri] 中任意的一个值。 

 设$S=\sum{x_i^2}$，求 S 种类数。、

**输入描述**:

```
第一行一个数 n。 
然后 n 行，每行两个数表示 li,ri。
```

**输出描述**:

```
输出一行一个数表示答案。
```

**思想&代码**

$dp[i][j]$表示在第i个数后S的值可以为j。

$dp[i][j] |= dp[i-1][j-k*k]， l\le k \le r$

用bool数组会卡空间，因此用bitset进行优化

$dp[i] \;|= dp[i-1] << (k*k)$

用01滚动还可以进一步优化空间

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 110;
const int maxf = maxn*maxn*maxn;
int l, r;
bitset<maxf> dp[2];
int n;

int main()
{
	scanf("%d", &n);
	dp[0][0] = 1;
	for(int i=1;i<=n;i++)
	{
		scanf("%d%d", &l,&r);
		for(int k=l;k<=r;k++)
		{
			dp[1] |= dp[0] << k*k;
		}
		dp[0] = dp[1];
		dp[1].reset();
	}
	printf("%d", dp[0].count());
	return 0;
}
```

#### Tian Ji -- The Horse Racing

Here is a famous story in Chinese history.

> That was about 2300 years ago. General Tian Ji was a high official in the country Qi. He likes to play horse racing with the king and others.
>
> Both of Tian and the king have three horses in different classes, namely, regular, plus, and super. The rule is to have three rounds in a match; each of the horses must be used in one round. The winner of a single round takes two hundred silver dollars from the loser.
>
> Being the most powerful man in the country, the king has so nice horses that in each class his horse is better than Tian's. As a result, each time the king takes six hundred silver dollars from Tian.
>
> Tian Ji was not happy about that, until he met Sun Bin, one of the most famous generals in Chinese history. Using a little trick due to Sun, Tian Ji brought home two hundred silver dollars and such a grace in the next match.
>
> It was a rather simple trick. Using his regular class horse race against the super class from the king, they will certainly lose that round. But then his plus beat the king's regular, and his super beat the king's plus. What a simple trick. And how do you think of Tian Ji, the high ranked official in China?
> ![img](https://te4p0t.github.io/assets/images/typora-user-images/202204262301691.jpeg)


Were Tian Ji lives in nowadays, he will certainly laugh at himself. Even more, were he sitting in the ACM contest right now, he may discover that the horse racing problem can be simply viewed as finding the maximum matching in a bipartite graph. Draw Tian's horses on one side, and the king's horses on the other. Whenever one of Tian's horses can beat one from the king, we draw an edge between them, meaning we wish to establish this pair. Then, the problem of winning as many rounds as possible is just to find the maximum matching in this graph. If there are ties, the problem becomes more complicated, he needs to assign weights 0, 1, or -1 to all the possible edges, and find a maximum weighted perfect matching...

However, the horse racing problem is a very special case of bipartite matching. The graph is decided by the speed of the horses -- a vertex of higher speed always beat a vertex of lower speed. In this case, the weighted bipartite matching algorithm is a too advanced tool to deal with the problem.

In this problem, you are asked to write a program to solve this special case of matching problem.

**Input**

The input consists of up to 50 test cases. Each case starts with a positive integer n ( n<=1000) on the first line, which is the number of horses on each side. The next n integers on the second line are the speeds of Tian's horses. Then the next n integers on the third line are the speeds of the king's horses. The input ends with a line that has a single `0' after the last test case.

**Output**

For each input case, output a line containing a single number, which is the maximum money Tian Ji will get, in silver dollars.

**Sample Input**

```
3
92 83 71
95 87 74
2
20 20
20 20
2
20 19
22 18
0
```

**Sample Output**

```
200
0
0
```

**思想&代码**

首先，这题有一部分贪心思想。首先将齐王和田忌的🐎都按照速度由大到小排序

1. 假设田忌的第一匹🐎，弱于齐王目前的第一匹🐎。那么可以用田忌最弱的那匹来输。这样交换可能有两种结果，田忌最弱的一匹弱于齐王最弱的一匹 且 当前的第一匹🐎强于齐王最后一匹，赚200；否则，和未交换前一样。稳赚不亏。（既然一定要输，就用最弱的一匹🐎去输，留下来最强的或许在之后可以多赢一局，最差也是和之前相同结果，因此交换即可）。
2. 田忌的第一匹🐎强于齐王第一匹🐎，此时并不需要用田忌**恰好大于齐王第一匹🐎**的🐎去交换，因为结果相同，并不会因为交换而产生收益。（无用功）

但这样的话有一种情况不好讨论，即若当前齐王的第一匹🐎和田忌的第一匹🐎平局，那么交换产生的收益可能为正也可能为负。

举个简单的例子

```c++
tian: 20 18
king: 20 19
```

若这种情况，不交换的话田忌-200；交换则0；交换是正收益的操作

```c++
tian: 20 19
king: 20 18
```

这种情况，交换是0；不交换是200；交换是负收益的操作。

因此平局的时候，是否要进行交换，由后续的状态决定。

因此这种贪心并不能解决问题。但我们发现了一个性质，当齐王的🐎按照由强到弱的顺序依次出战时，田忌只会用最强的🐎或者最弱的🐎来应战。在第k轮，田忌剩余的🐎仍是一个连续的区间。那么可以转化为一个dp问题

设$dp[k][i][j]$表示在第k轮田忌还剩下[i, j]区间内的🐎没有上阵。

$dp[k][i][j] = max\{dp[k-1][i-1][j]+shouyi(k, i-1), dp[k-1][i][j+1]+shouyi(k, j+1) \}$

又有关系式$j-i+1+k = n$

所以j可以用n, k, i来表示，转化为二维dp问题。

```c++
#include<stdio.h>
#include<algorithm>
using namespace std;
#define INF 0x3f3f3f3f
const int maxn = 2010;

int n, tian[maxn], king[maxn];
int dp[maxn][maxn];
int ans = -INF;

bool cmp(int x, int y)
{
	return x>y;
}

int shouyi(int x, int y)
{
	if(king[x]>tian[y]) return -200;
	else if(king[x]==tian[y]) return 0;
	else return 200;
}

int main()
{
	scanf("%d", &n);
	while(n!=0)
	{
		for(int i=1;i<=n;i++) scanf("%d", &tian[i]);
		for(int i=1;i<=n;i++) scanf("%d", &king[i]);
		ans = -INF;
		sort(tian+1, tian+1+n, cmp);
		sort(king+1, king+1+n, cmp);
		// for(int i=1;i<=n;i++) cout << tian[i] << " \n"[i==n];
		// for(int i=1;i<=n;i++) cout << king[i] << " \n"[i==n];
		for(int k=1;k<=n;k++)
		{
			for(int i=1;i<=k+1;i++)
			{
				if(i==1) dp[k][i] = dp[k-1][i] + shouyi(k, n+i-k);
				else if(i==k+1) dp[k][i] = dp[k-1][i-1] + shouyi(k, i-1);
				else dp[k][i] = max(dp[k-1][i-1]+shouyi(k, i-1),
								dp[k-1][i]+shouyi(k, n+i-k));
				//cout << k << ' ' << i <<' ' << dp[k][i] <<endl;
			}
		}
		for(int i=1;i<=n;i++)
		{
			ans = max(ans, dp[n][i]);
		}
		printf("%d\n", ans);
		scanf("%d", &n);
	}
	return 0;
}
```

#### Maxnium sum

**Description**

Given a set of n integers: A={a1, a2,..., an}, we define a function d(A) as below:

![image-20220225135254079](https://te4p0t.github.io/assets/images/typora-user-images/202204262301999.png)

Your task is to calculate d(A).

**Input**

The input consists of T(<=30) test cases. The number of test cases (T) is given in the first line of the input.
Each test case contains two lines. The first line is an integer n(2<=n<=50000). The second line contains n integers: a1, a2, ..., an. (|ai| <= 10000).There is an empty line after each case.

**Output**

Print exactly one line for each test case. The line should contain the integer d(A).

**思想&代码**

最大子串和进阶版本

最大子串和$dp[i] = max(dp[i-1]+a[i], a[i])$

计算两个最大子串和，一个表示以a\[i\]为终点的最大子串和，一个表示以a\[i\]为起点的最大子串和。

再做一次前缀最大计算，得到一个表示以到a\[i\]为止的最大子串和（可能不包含a\[i\]），和一个表示从a\[i\]开始的最大子串和（可能不包含a\[i\]）

再枚举断点计算最大值。

```c++
#include<stdio.h>
#include<math.h>
#include<iostream>
using namespace std;
#define INF 0x3f3f3f3f
const int maxn = 50010;
int T, n;
int a[maxn];
long long dp1[maxn], dp2[maxn], pre1[maxn], pre2[maxn];
long long ans = -INF;

int main()
{
	scanf("%d", &T);
	while(T--)
	{
		for(int i=0;i<maxn;i++) dp1[i] = dp2[i] = pre1[i] = pre2[i] = -INF;
		ans = -INF;
		scanf("%d", &n);
		for(int i=1;i<=n;i++)
		{
			scanf("%d", &a[i]);
		}
		for(int i=1;i<=n;i++)
		{
			dp1[i] = max(dp1[i-1]+a[i], 1ll*a[i]);
			pre1[i] = max(pre1[i-1], dp1[i]);
		}
		for(int i=n;i>0;i--)
		{
			dp2[i] = max(dp2[i+1]+a[i], 1ll*a[i]);
			pre2[i] = max(pre2[i+1], dp2[i]);
		}
		for(int i=0;i<=n;i++)
		{
			ans = max(ans, dp1[i]+dp2[i+1]);
		}
		for(int i=1;i<n;i++)
		{
			ans = max(ans, pre1[i] + pre2[i+1]);
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

#### 多个不相交字段和问题

- 给定一个长度为n的数组，求在其中找m个不相交子串和最大值的问题

**思想**

- $f[i][j]$表示前i个数（第i个数必须取）组成j个不相交子段所能取得的最大和。
- 第i个数必须取有两种可能，一是作为前段子串的新元素，另一是作为一个新子串的起点。
- 若是作为一个新子串的起点，那么上一个选的数可能是之前的任意个数。
- $f[i][j] = max\{f[i-1][j]+a[i], f[k][j-1]+a[i] \},\quad 1\le k\le i-1$

这样的话复杂度是$O(n^2*m)$，考虑将枚举k的循环优化掉。

![image-20220306233303282](https://te4p0t.github.io/assets/images/typora-user-images/202204262301595.png)

每一次状态的转移实际上是，从该节点的上方一格，或者从左上方的一列转移过来。左上方的一列就是对k的循环，而这个循环可以用一个前缀最大值数组来优化掉。

$f[i][j] = max\{f[i-1][j]+a[i], maxn[i-1][j-1]+a[i] \}$

**或者**

在状态中加一个维度

$f[i][j][1/0]$表示第i个数选（1），不选（0），组成j个不相交子串和最大值。

$f[i][j][0] = max\{f[i-1][j][0] + f[i-1][j][1] \}$

$f[i][j][1] = max\{f[i-1][j][1]+a[i], f[i-1][j-1][0]+a[i], f[i-1][j-1][1]+a[i]  \}$

实际上多加了一个状态中，$f[i][j][0]+f[i][j][1]$的值就是上一种方法中的$maxn[i][j]$

#### 多个不相交字段和问题（环状？）

考虑将环从1，n之间断开

假设选m个区间，两种情况

1. 选取区间后，在断点出无区间，则和上题一样。
2. 选取区间后，有一个区间中包含断点。
   - 包含断点的情况，实际上就是在1, n中间选m+1个区间，其中1和n必选。
   - 状态和上题一致$f[i][j][0/1]$，只需特殊判断$f[i][1][1]$为子串前缀和，$f[i][1][0] = max\{f[i-1][1][1], f[i-1][1][0] \}$,同时最后求解答案时求的是$f[n][m+1][1]$



### 综合习题

- 

#### 拦截导弹

**思想&代码**

第一问求最长不上升子序列。

第二问最直观的方法：求完一次不上升子序列后把刚才要打的导弹去掉，再求一次最长不上升子序列直到打完所有的导弹。

但是存在反例

```c++
6 1 7 3 2
错解：6 3 2/1/7
正解：6 1/7 3 2
```

定理：**完整覆盖一个序列的不上升子序列的个数等于这个序列的最长上升子序列的长度。**

严格证明要参考偏序集的Dilworth定理。

比较随意的证明方法

假设该序列最长上升子序列长度为k。则该最长上升子序列中的每一个导弹至少需要一个系统，所以系统数量最小应为k。

下面证明系统数量最大应为k：

- 假设k个系统不能覆盖所有导弹。

- 假设现有k套系统覆盖了部分导弹，如果第k+1套系统覆盖的第一枚导弹在序列开头。

  1. 若它的高度大于等于下一个最近的另一套系统覆盖的导弹，则可以归到另一套系统中；
  2. 若小于的话，则最长上升子序列长度就应该是k+1，与假设矛盾。

- 若第k+1套系统覆盖的第一枚导弹在某两序列中间。这两序列中前一个序列第一个导弹应当小于后一个序列的第一个导弹高度。

  1. 若k+1套系统覆盖的第一枚导弹的高度高于后一个系统的第一个导弹，则可以合并到后一个系统中。
  2. 若k+1套系统覆盖的第一枚导弹高度在左右两系统第一个导弹的高度之间，则最长上升子序列的长度应为k+1，与假设矛盾。
  3. 若k+1套系统覆盖的第一枚导弹高度小于左系统第一个导弹高度，那它必须小于该系统中所有在他左边的导弹的高度（否则最长上升子序列长度k+1），那么该枚导弹可以被合并到左侧的系统中。

  综上所述，系统数量最大应为k。

  所以系统数量为k。

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 1e5+10;
int h[maxn];
int dp1[maxn], dp2[maxn];
int cnt=0, ans1, ans2;

int main()
{
	memset(dp1, 0, sizeof(dp1));
	while(scanf("%d", &h[++cnt])!=EOF)
	{
		dp1[cnt] = 1;
		dp2[cnt] = 1;
		for(int i=1;i<cnt;i++)
		{
			if(h[i]<h[cnt]) dp1[cnt] = max(dp1[cnt], dp1[i]+1);
			if(h[i]>=h[cnt]) dp2[cnt] = max(dp2[cnt], dp2[i]+1);
			ans2 = max(ans2, dp1[cnt]);
			ans1 = max(ans1, dp2[cnt]);
		}
	}
	// for(int i=1;i<=cnt;i++) cout << dp1[i] << " \n"[i==cnt];
	// for(int i=1;i<=cnt;i++) cout << dp2[i] << " \n"[i==cnt];
	printf("%d\n%d", ans1, ans2);
	return 0;
}
```

#### 数学考试

链接：https://ac.nowcoder.com/acm/contest/24213/1013
来源：牛客网

**题目描述**                    

今天qwb要参加一个数学考试，这套试卷一共有n道题，每道题qwb能获得的分数为ai，qwb并不打算把这些题全做完，
 他想选总共2k道题来做，并且期望他能获得的分数尽可能的大，他准备选2个不连续的长度为k的区间,
 即[L,L+1,L+2,....,L+k-1]，[R,R+1,R+2,...,R+k-1]（R >= L+k）。

**输入描述**:

```
第一行一个整数T（T<=10）,代表有T组数据
接下来一行两个整数n,k,(2<=n<=200,000),(1<=k,2k <= n)
接下来一行n个整数a1,a2,...,an，（-100,000<=ai<=100,000）
```

**输出描述**:

```
输出一个整数，qwb能获得的最大分数
```

**思想&代码**

首先考虑用前缀和数组pre方便计算k长度区间和。

之后开两个dp

$dp1[i]$表示以i或大于i的数为起点，区间长度为k的最大区间和。

$dp2[i]$表示以i或小于i的数为终点，区间长度为k的最大区间和。

$dp1[i] = max(dp1[i+1], pre[i+k-1]-pre[i-1])$

$dp2[i] = max(dp2[i-1], pre[i]-pre[i-k])$

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 2e5+10;

int T, n, k;
long long a[maxn], dp1[maxn], dp2[maxn], pre[maxn];
long long ans=-1e15;


int main()
{
	scanf("%d", &T);
	while(T--)
	{
		ans = -1e15;
		scanf("%d%d", &n, &k);
		for(int i=1;i<=n;i++)
		{
			scanf("%lld", &a[i]);
			pre[i] = pre[i-1] + a[i];
		}
		// for(int i=1;i<=n;i++) cout << pre[i] <<" ";
		// cout <<end
		memset(dp1, -0x3f, sizeof(dp1));
		memset(dp2, -0x3f, sizeof(dp2));
		for(int i=n-k+1;i>=1;i--)
		{
			dp1[i] = max(dp1[i+1], pre[i+k-1]-pre[i-1]);
		}
		for(int i=k;i<=n;i++) dp2[i] = max(dp2[i-1], pre[i]-pre[i-k]);
// 		for(int i=1;i<=n;i++) cout << dp1[i] <<" ";
// 		cout << endl;
// 		for(int i=1;i<=n;i++) cout <<dp2[i] << " ";
// 		cout << endl;
		for(int i=1;i<n;i++)
		{
			ans = max(ans, dp1[i+1] + dp2[i]);
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

当然只开一个dp数组也可。

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 2e5+10;

int T, n, k;
long long a[maxn], dp1[maxn], dp2[maxn], pre[maxn];
long long ans=-1e15;


int main()
{
	scanf("%d", &T);
	while(T--)
	{
		ans = -1e15;
		scanf("%d%d", &n, &k);
		for(int i=1;i<=n;i++)
		{
			scanf("%lld", &a[i]);
			pre[i] = pre[i-1] + a[i];
		}
		memset(dp2, -0x3f, sizeof(dp2));
		for(int i=k;i<=n;i++) dp2[i] = max(dp2[i-1], pre[i]-pre[i-k]);
		for(int i=1;i<=n-k;i++)
		{
			ans = max(ans, dp2[i]+pre[i+k]-pre[i]);
		}
		printf("%lld\n", ans);
	}
	return 0;
}
```

#### 小A买彩票

链接：https://ac.nowcoder.com/acm/contest/24213/1014
来源：牛客网

**题目描述**                    

小A最近开始沉迷买彩票，并且希望能够通过买彩票发家致富。已知购买一张彩票需要3元，而彩票中奖的金额分别为1,2,3,4元，并且比较独特的是这个彩票中奖的各种金额都是等可能的。现在小A连续购买了n张彩票，他希望你能够告诉他至少能够不亏本的概率是多少。

**输入描述**:

```
一行一个整数N，为小A购买的彩票数量一行一个整数N，为小A购买的彩票数量一行一个整数N，为小A购买的彩票数量
```

**输出描述**:

```
输出一个最简分数a/b，表示小A不亏本的概率。若概率为1，则输出1/1，概率为0，则输出0/1。输出一个最简分数a/b，表示小A不亏本的概率。
\\若概率为1，则输出1/1，概率为0，则输出0/1。输出一个最简分数a/b，表示小A不亏本的概率。若概率为1，则输出1/1，概率为0，则输出0/1。
```

**思想&代码**

设$dp[i][j]$表示买到第i个彩票时，小A净收益100+j元的方案数。

那么$dp[i][j] = \sum\limits_{k=j-1}^{j+2}dp[i-1][k]$

答案用方案数除以总数$4^n$即可

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 35;

long long n, dp[maxn][201];
long long ans = 0;


int main()
{
	scanf("%lld", &n);
	dp[0][100] = 1;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=198;j++)
		{
			dp[i][j] = dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1] + dp[i-1][j+2];
		}
	}
	// for(int i=1;i<=n;i++)
	// {
		// for(int j=80;j<=120;j++)
		// cout << dp[i][j] << " ";
		// cout << endl;
	// }
	for(int i=100;i<=200;i++)
	{
		ans += dp[n][i];
	}
	//cout << ans << ' ' << pow(4, n) << ' ' << gcd(ans, pow(4, n)) << ' ' << pow(4, n) / gcd(ans, pow(4, n))<< endl;
	printf("%lld/%lld", ans/__gcd(ans, (long long)pow(4, n)), (long long)pow(4, n) / __gcd(ans, (long long)pow(4, n)));
	return 0;
}
```

#### 购物

链接：https://ac.nowcoder.com/acm/contest/24213/1015
来源：牛客网

**题目描述**                    

   在遥远的东方，有一家糖果专卖店。  

   这家糖果店将会在每天出售一些糖果，它每天都会生产出m个糖果，第i天的第j个糖果价格为C[i][j]元。  

   现在的你想要在接下来的n天去糖果店进行选购，你每天可以买多个糖果，也可以选择不买糖果，但是最多买m个。（因为最多只生产m个）买来糖果以后，你可以选择吃掉糖果或者留着之后再吃。糖果不会过期，你需要保证这n天中每天你都能吃到至少一个糖果。  

   这家店的老板看你经常去光顾这家店，感到非常生气。（因为他不能好好睡觉了）于是他会额外的要求你支付点钱。具体来说，你在某一天购买了 k 个糖果，那么你在这一天需要额外支付 k2 的费用。  

   那么问题来了，你最少需要多少钱才能达成自己的目的呢？  

 **输入描述**:

```
第一行两个正整数n和m，分别表示天数以及糖果店每天生产的糖果数量。
接下来n行（第2行到第n+1行），每行m个正整数，第x+1行的第y个正整数表示第x天的第y个糖果的费用。
```

**输出描述**:

```
输出只有一个正整数，表示你需要支付的最小费用。
```

**思想&代码**

该题中包含部分贪心的思想：

若第i天要买k个糖果，那么必定选价值最小的前k个。用一个前缀和维护一下前k个糖果代价。

设$dp[i][j]$代表第i天有j个糖果的最小代价，则状态转移方程为

$dp[i][j] = min\{dp[i-1][j], \sum\limits_{k=i-1}^{n} dp[i-1][k] + pre[j-k] + (j-k)^2 \}$

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn = 310;
int dp[maxn][maxn];
int a[maxn], n, m;

int main()
{
	scanf("%d%d", &n, &m);
	memset(dp, 0x3f, sizeof(dp));
	dp[0][0] = 0;
	for(int i=1;i<=n;i++)
	{
		for(int j=1;j<=m;j++)
		{
			scanf("%d", &a[j]);
		}
		sort(a+1, a+m+1);
		for(int j=2;j<=m;j++)
		{
			a[j] += a[j-1];
		}
		for(int j=i;j<=n;j++)
		{
			dp[i][j] = dp[i-1][j];
			for(int k=i-1;k<=n;k++)
			{
				dp[i][j] = min(dp[i][j], dp[i-1][k] + a[j-k] + (j-k)*(j-k));
			}
		}
	}
	printf("%d", dp[n][n]);
	return 0;
}
```

#### 牛牛的旅游纪念品

链接：https://ac.nowcoder.com/acm/contest/24213/1016
来源：牛客网

**题目描述**                    

  牛牛在牛市的旅游纪念商店里面挑花了眼，于是简单粗暴的牛牛决定——买最受欢迎的就好了。 

  但是牛牛的背包有限，他只能在商店的n个物品里面带m个回去，不然就装不下了。 

  并且牛牛希望买到的纪念品不要太相似，所以导购小姐姐帮助牛牛把纪念品全部排成了一行，牛牛只需要让选出来要买的m个物品中任意两个的位置差都大于等于k就行了。 

  现在告诉你这n个物品排成一行之后的受欢迎程度（可能是负数），求牛牛带回去的m个物品的最大欢迎度之和。 

**输入描述**:

```
 第一行三个数n,m,k 接下来一行,有n个整数,是n个物品按顺序的受欢迎程度。
```

**输出描述**:

```
输出一个数为题目所求的最大和
```

**思想&代码**

设$dp[i][j]$表示第i个物品选在j位置，则有状态转移方程

$dp[i][j] = {pre[i-1][t] + a[j] }$

其中pre为前缀最大值，表示第i个物品，在j位置前最小的代价和。

```c++
#include<bits/stdc++.h>
using namespace std;

const int maxn=1e4+10;
const int maxm=110;
int a[maxn];
int dp[maxm][maxn], n, m, k;
int pre[maxm][maxn];

int main()
{
	scanf("%d%d%d", &n, &m, &k);
	for(int i=1;i<=n;i++) scanf("%d", &a[i]);
	memset(pre, 0xe3, sizeof(pre));
	for(int i=1;i<=m;i++)
	{
		for(int j=(i-1)*k+1;j<=n;j++)
		{
			if(i==1) dp[i][j] = a[j];
			else dp[i][j] = max(dp[i][j], dp[i-1][j-k] + a[j]);
			pre[i][j] = max(dp[i][j], pre[i][j-1]);
		}
	}
	printf("%d", pre[m][n]);
	return 0;
}
```



#### 三个串的最长公共子序列

- 给定三个串，求其最长公共子序列，输出最长公共子序列的方案。

**思想**

$f[i][j][k]$表示第一个串前i个字符，第二个串前j个字符，第三个串前k个字符。

$a[i]==b[i]==c[i]$，$f[i][j][k] = f[i-1][j-1][k-1]+1$

else $f[i][j][k] = max\{f[i-1][j][k], f[i][j-1][k], f[i][j][k-1] \}$

如何求得方案？

1. 可以用一个数$last[i][j][k]$求当前方案是由哪一个状态转移过来的。
2. 直接将$f[i][j][k]$开成字符串，记录当前公共子序列。

#### 最大子矩阵

- 在一个矩阵中找到一个子矩阵，该子矩阵和最大，输出最大和。

**思想**

二维前缀和，求的话复杂度是$O(n^2)$

优化：

- 枚举行（子矩阵从第i行到第j行，i和j都要枚举）
- 然后把第i行到第j行压成一行（通过对每一列求前缀和实现）
- 对得到的一行求最大子串和

#### 骨牌

- 多米诺骨牌有上下两个方块组成，每个方块中有1~6个点。现有排成行的上方块中点数之和记为S1，下方块中点数之和记为S2，他们的差为|S1-S2|。例如在图8-1中，S1=6+1+1+1=9，S2=1+5+3+2=11，|S1-S2|=2。每个多米诺骨牌可以旋转180°，使得上下两个方块互换位置。编程用最少的旋转次数使多米诺骨牌上下2行点数之差达到最小。对于图中的例子，只要将最后一个多米诺骨牌旋转180°，可使上下2行点数之差为0。

**思想**

$f[i][j]$表示前i个牌，使上-下的差为j时的最小翻转次数。

$f[i][j]=min\{f[i-1][j-(a_上-a_下)], f[i-1][j-(a_下-a_上)]+1 \}$



#### Bitset优化背包

- 一共有n个数，第i个数是$x_i$
- $x_i$可以取$[l_i, r_i]$中任意一个值
- 设$S=\sum x_i^2$，求S的种类数。

**NC 16655 [NOIP2005] 过河**

**思想**

一般想法

- $f[i]$表示青蛙要到第i这个位置所需要踩过的最小的石子数量。
- $f[i] = max(f[i-k])+(shizi[i]==1),\ S \le k \le T$

但是L的范围过大，时间和空间复杂度均不允许。观察石子数量的范围，最大才100。

此时用到一个定理

![img](https://te4p0t.github.io/assets/images/typora-user-images/202204262301672.png)

若p1和p2互素任意大于$p_1*p_2$的数都可以由$xp_1+yp_2$组成，且x，y均大于0。

又S和T最大为10，那么我们对石子进行处理，当相邻两石子的距离大于100时，将它改为100。那么可极大降低时间和空间复杂度。(不一定100，可再开大)

#### CF505C Mr. Kitayuta, the Treasure Hunter

- 一共有30001个岛屿，下标为0到30000，有些岛屿藏有宝藏。你从0往下标大的方向跳，第一 步跳的距离为d。如果上一步跳的距离为l，这一步就可以跳l-1或l+1（距离必须大于0）问最多拿到多少宝藏。

**思想**

$f[i][j]$表示到i位置，上一步调了j长度，所能得到的宝藏数量的额最大值。

$f[i][j] = max\{f[i-j][j-1], f[i-j][j+1] \}+baozang[i]$

这样的话i和j的范围都是30000。数组开不下。

但是我们考虑题目中限制步数的规则，每一次的步数只有可能是上一次步数加减1。

假设从1开始，每次加1，那么最多加到300就会大于岛屿的范围。所以说j相对距离初始值的浮动不会超过正负300，那么j可以改为与初始距离相对距离的值。这样就可以降低空间和时间复杂度。

#### Codeforces 510D Fox And Jumping

- 给定N个不同的数，取第i个数的代价为c\[i\]，求取出若干个数使得其最大公约数为1的最小代价
- $1\le n\le 300$
- $l[i]\le10^9$

**想法**

$f[i][j]$表示前i个数，最大公约数为j的最小代价

$f[i][j] = min\{f[i-1][j], f[i-1][k]\},\ gcd(k, l[i])==j$

因为数的范围很大，空间复杂度太大。

但是在dp的过程中，最大公约数的个数应该是很小的。

用Map做一个映射，从而降低第二维的范围。
