---
layout: post
title: 简单数学基础
subheading: 算法中的简单数学基础
author: te4p0t
categories: coding
tags: Coding

---



# 简单数学基础

## 综述

- **数论**：数论是纯粹数学的分支之一，主要研究整数的性质。初等数论主要包括整除理论、同余理论、连分数理论。
- **组合数学**：广义的组合数学就是离散数学，狭义的组合数学是离散数学除图论、代数结构、数理逻辑等的部分。组合数学的主要内容有组合计数、组合设计、组合矩阵、组合优化（最佳组合）等。
- **线性代数**：线性代数是数学的一个分支，它的研究对象是向量，向量空间（或称线性空间），线性变换和有限维的线性方程组。
- **概率与期望**：概率论是研究随机现象数学规律的数学分支。事件的概率是衡量该事件发生的可能性的量度。数学期望是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。
- **博弈论**：博弈论又被称为对策论（Game Theory），既是现代数学的一个新分支，也是运筹学的一个重要学科。博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。
- **计算几何**：计算几何是几何外形信息的计算机表示、分析和综合。

## 数论

### 质数

质数（prime number）又叫素数，一个大于1的自然数，除了1和它自身外，不能被其他自然数整除的数叫做质数；否则称为合数。

#### 性质

- 在N>3时，在任何的N和N+1之中必然有一个数不是质数。

- 质数有无穷多个。

- 存在任意长的一段连续数，其中的所有数都是合数（相邻素数之间的间隔任意大）。

- N以内的素数的个数随着N的增大趋近于$\log n$

- 从不大于n的自然数随机选一个数，它是素数的概率大约是$\displaystyle \frac{1}{\ln n}$​​（素数定理）。

- 随着n的增大，素数越来越稀疏（整体上）。

- 在一个大于1的数和它的2倍之间（即区间$(a, 2a]$中）必存在至少一个素数。

#### 猜想

- 孪生素数猜想：N和N+2都为素数的情况有很多，这样的一对素数叫做孪生素数（eg: 3和5， 5和7， 11和13， 1e9+7和1e9+9）。
- 哥德巴赫猜想：任意大于2的正偶数都可以写成两个素数的和。
- （一个充分大偶数必定可以写成一个素数加上一个最多由2个质因子所组成的合成数，简称为（1+2））。

### 素数判定

#### 暴力判定

枚举2到$\sqrt[2]{n}$的所有数，看能否整除n。复杂度：$O(\sqrt{n})$

#### 暴力判定的再优化

结论

> 大于等于5的质数一定和6的倍数相邻

证明：

![image-20220303193059958](https://te4p0t.github.io/assets/images/typora-user-images/202204262259682.png)

- 令$x$

```c++
bool isprime(long long num)
{
     if(num==2 || num==3) return 1;
     if(num%6!=1 && num%6!=5) return 0;
     int tmp = sqrt(num);
     for(int i=5;i<=tmp;i+=6 )
        if(num%i==0 || num%(i+ 2)==0) return 0 ;
     return 1 ;
}
```



#### 素数筛法

##### 埃氏筛法

由古希腊的数学家埃拉托塞尼提出

要得到不大于某个自然数N的所有素数，只要在2—N中将不大于$\sqrt[2]{N}$​的素数的倍数全部划去即可。

```c++
void aishai()
{
	for(int i=2;i<=n;i++)
	{
		if(!b[i])
		{
			for(int j=i+i;j<=n;j+=i) b[j] = 1;
		}
	}
}
```



###### 小优化

- 对于每个合数，我们都可以表示为a*b， 其中a是一个质数，b可能是质数可能是合数。
- 若a>b，那么a*b在用a筛掉其倍数之前就已经被b或者b的质因子筛掉了。
- 所以，用a筛掉其倍数的时候，我们只需要从a*a开始枚举。

```c++
void aishai()
{
	for(int i=2;i*i<=n;i++)
	{
		if(!b[i])
			for(int j=i*i;j<=n;j+=i)
				b[j] = 1;
	}
}
```

埃氏筛法的时间复杂度$O(\sum_{质数_{p \le N}}\frac{N}{P}) = O(N \log {\log N})$​

#### 线性筛

**欧拉筛**

- 优化过的埃氏筛法还是会有重复的，如：12既会被2标记又会被3标记
- 我们希望一个合数只用一个素数来标记删掉

**方法**

- 我们用数组v记录每个数的最小质因子
- 依次考虑2~N的每一个数I
- 如果v[i]=i那么i是质数，把它存下来
- 扫描小于等于v[i]的所有质数，令v[i\*p]=p，也就是在i上积累一个质因子。因为$p\le v[i]$那么p是i\*p的最小质因子，i\*p是个合数。

```c++
for(int i=2;i<=n;i++)
{
    if(v[i] == 0) {v[i] = i; prime[++cnt] = i;}
    for(int j=1;j<=cnt;j++)
    {
        if(prime[j] > v[i] || i*prime[j] > n) break;
        v[i*prime[j]] = prime[j];
    }
}
```

#### 例题

**题目描述**

- 给你两个整数L, R求区间[L, R]中相邻的两个质数的差值最大是多少
- ($L, R \le 2^{31}, R-L\le10^{6}$)

**思想&代码**

- 用素数筛无法开$2^{31}$的数组，枚举的话复杂度$O(n*\sqrt{n})$又过不了
- 但其实枚举不需要从2一直枚举到$\sqrt{n}$，只需要枚举小于$\sqrt{n}$的素数即可。而素数的分布式接近$O(\log n)$的，因此先用素数筛筛出$\sqrt{n}$的素数，再去遍历区间，最后复杂度为$O({n\log n})$。

### 算数基本定理

任何一个大于1的正整数都能唯一分解为有限个质数的乘积，可以写作：

$$N=p_1^{c_1}p_2^{c_2}p_3^{c_3}p_4^{c_4}...p_m^{c_m}$$

其中$p_1, p_2, p_3, p_4...p_n$都是质数且递增，$c_i$都是正整数

**分解质因数**

试除法，把小于$\sqrt[2]{n}$​的质数都试一遍。

#### 推论

$$N=p_1^{c_1}p_2^{c_2}p_3^{c_3}p_4^{c_4}...p_m^{c_m}$$

- 那么N的正约数合集为$\{p_1^{b_1}p_2^{b_2}...p_m^{b_m}\}$​，其中$0\le b_i \le c_i$​​

- N的正约数个数为$\prod^m_{i=1}(c_i+1)$​​

- N的所有正约数的和为$(1+p_1+p_1^2+...+p_1^{c_1})*...*(1+p_m+p_m^2+...+p_m^{c_m}) = \prod^m_{i=1}({\sum^{c_i}_{j=0}(p_m)^j})$​​